\documentclass{beamer}

\usetheme{Copenhagen}

\title{Git Branching and Merging}
\author{Mike DeLaurentis}
\date{May 13, 2013}
\date{}

\begin{document}

\begin{frame}[plain]
\titlepage
\end{frame}

\begin{frame}[plain]
\begin{huge}

Why branch?

\end{huge}
\end{frame}

\begin{frame}[plain]

\begin{LARGE}
\begin{itemize}

\item Keep unrelated efforts separate from each other until ready
\item Separate experimental or in-progress features from stable code
\item Maintain diverging versions of code
\item Quickly patch a production issue, without including half-done features

\end{itemize}
\end{LARGE}
\end{frame}


\begin{frame}[plain]

\begin{center}
\begin{Large}
 In older source control systems,

\vspace{0.2in}

 (CVS, Subversion),

\vspace{0.2in}

 merging was hard
\end{Large}
\end{center}

\end{frame}

\begin{frame}[plain]
  \begin{center}
    \includegraphics[scale=0.6]{now_i_cant_merge.jpg}
  \end{center}
\end{frame}


%\begin{frame}[plain]
%  \includegraphics[scale=0.4]{no_conflicts.jpg}
%\end{frame}


\begin{frame}[plain]

But git changes all that

\end{frame}

\section{Branch / merge primer}

\begin{frame}

How?


\begin{small}
  
\begin{quote}
... it's simplest to think of the state of your repository as a point
in a high-dimensional 'code-space', in which branches are represented
as n-dimensional membranes, mapping the spatial loci of successive
commits onto the projected manifold of each cloned repository.
\end{quote}
\end{small}
\begin{center}

      \includegraphics[scale=0.5]{I1546manifold.png}      
  
\end{center}
\end{frame}

\begin{frame}[plain]
Actually, I don't really know.
It just makes branching and merging easier.
\end{frame}

\begin{frame}[plain]

\begin{Large}
\begin{itemize}

\item Sequence of commits
\item Starts by diverging from another branch
\item {\it May be} merged back into other branch(es) zero or more times
\item Can even cherry-pick individual commits from a branch
\item Can usually avoid crazy mess when merging
\end{itemize}
\end{Large}
\end{frame}


\begin{frame}[plain]
Unsolicited advice:
\begin{itemize}
\item Commit often
\item Use branches more than you do
\end{itemize}

\end{frame}


\begin{frame}[plain]
Commit often:
  \begin{itemize}
  \item You can always change it later
  \item Commits are atomic
  \end{itemize}
\end{frame}


\begin{frame}[plain]
What should I use branches for?  
\end{frame}


\begin{frame}[plain]
(credit)
\end{frame}

\begin{frame}[plain]

  Maintain a pointer to latest production code

  \begin{itemize}
  \item {\tt master} branch
  \item Nothing special about it, just a sensible default name
  \item Head is always production-ready
  \item Never actively committed to
  \item Lives forever
  \end{itemize}

\end{frame}

\begin{frame}[plain]

  Maintain a branch for latest developed features

  \begin{itemize}
  \item {\tt develop} branch
  \item Maybe not production-ready,
  \item but at least shareable
  \item Often branched from, merged back into
  \item Lives forever
  \end{itemize}

\end{frame}

\begin{frame}[plain]

  Make a branch for a feature or small set of features

  \begin{itemize}
  \item ``feature'' branch, named after specific feature
  \item Short-lived
  \item Branch from ``develop''
  \item Merge back into ``develop''
  \item Delete when finished with it
  \end{itemize}

\end{frame}


\begin{frame}[plain]

  Make a little branch to finalize a release

  \begin{itemize}
  \item {\tt release-}x.x branch
  \item Used to finish a release (bump version number, release date)
  \item Branch from master
  \item Merge into develop and master
  \item Delete when finished with it
  \end{itemize}

\end{frame}

\begin{frame}[plain]

  Make hot-fixes on their own branches

  \begin{itemize}
  \item {\tt hotfix-}* branch
  \item Used to address issue found in ``production''
  \item Branch from master
  \item Merge into develop and master
  \item Name after version number or issue number
  \item Delete when finished with it
  \end{itemize}

\end{frame}

\end{document}
